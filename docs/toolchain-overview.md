# Toolchain Overview

RISC-V，作为一个较新的ISA，从未被完整实现过。因此想要在现有工具链上进行开发，读者有必要熟悉工具链中众多的workaround和undocumented features。

## RISC-V Tools

官方的[riscv-tools](https://github.com/riscv/riscv-tools)由以下部分组成

* `riscv-gnu-toolchain`, a RISC-V cross-compiler
* `riscv-fesvr`, a "front-end" server that services calls between the host and target processors on the Host-Target InterFace (HTIF) (it also provides a virtualized console and disk device)
* `riscv-isa-sim`, the ISA simulator and "golden standard" of execution
* `riscv-opcodes`, the enumeration of all RISC-V opcodes executable by the simulator
* `riscv-pk`, a proxy kernel that services system calls generated by code built and linked with the RISC-V Newlib port (this does not apply to Linux, as _it_ handles the system calls)
* `riscv-tests`, a set of assembly tests and benchmarks


下面简要介绍这些工具主要的undocumented features，详细内容请参阅各个lab的移植文档。

| Tool                | Features                                 |
| ------------------- | ---------------------------------------- |
| riscv-gnu-toolchain | 编译时使用`-b binary`选项导致ld发生`segmentation fault` |
| riscv-fesvr         | 不存在所谓的`disk device`                      |
| riscv-isa-sim       | `rdtime`指令未实现，运行速度2MHz                   |
| riscv-pk            | proxy kernel不支持32位程序，存在大量workaround      |

## All About BBL

以下所有讨论只适用于Spike模拟器和QEMU上对应的`spike-board`实现，在其他RISC-V平台上未必正确。

### Compilation

bbl使用了[**Autotools**](https://www.gnu.org/software/automake/manual/html_node/Autotools-Introduction.html)作为构建系统，编译过程如下

```bash
$ mkdir build && cd build
$ ../configure --prefix=$RISCV --host=riscv32-unknown-linux-gnu --with-payload=/path/to/kernel
$ make
```

若不传入`--with-payload`选项，则默认使用`dummy_payload`，读者应当查看`bbl/payload.S`和`dummy_payload/`以初步了解bbl加载kernel的原理。

`payload.S`如下

```nasm
.section ".payload","a",@progbits
.align 3

.globl _payload_start, _payload_end
_payload_start:
.incbin BBL_PAYLOAD
_payload_end:
```

要注意`.align 3`并非3字节对齐而是$2^3$字节对齐。

### Linker Script

bbl的linker script如下

```
OUTPUT_ARCH( "riscv" )

ENTRY( reset_vector )

SECTIONS
{
  /*--------------------------------------------------------------------*/
  /* Code and read-only segment                                         */
  /*--------------------------------------------------------------------*/

  /* Begining of code and text segment */
  . = 0x80000000;
  _ftext = .;
  PROVIDE( eprol = . );

  .text :
  {
    *(.text.init)
  }

  /* text: Program code section */
  .text : 
  {
    *(.text)
    *(.text.*)
    *(.gnu.linkonce.t.*)
  }

  /* rodata: Read-only data */
  .rodata : 
  {
    *(.rdata)
    *(.rodata)
    *(.rodata.*)
    *(.gnu.linkonce.r.*)
  }

  /* End of code and read-only segment */
  PROVIDE( etext = . );
  _etext = .;

  /*--------------------------------------------------------------------*/
  /* HTIF, isolated onto separate page                                  */
  /*--------------------------------------------------------------------*/
  . = ALIGN(0x1000);
  htif :
  {
    *(htif)
  }
  . = ALIGN(0x1000);

  /*--------------------------------------------------------------------*/
  /* Initialized data segment                                           */
  /*--------------------------------------------------------------------*/

  /* Start of initialized data segment */
  . = ALIGN(16);
   _fdata = .;

  /* data: Writable data */
  .data : 
  {
    *(.data)
    *(.data.*)
    *(.srodata*)
    *(.gnu.linkonce.d.*)
    *(.comment)
  }

  /* End of initialized data segment */
  . = ALIGN(4);
  PROVIDE( edata = . );
  _edata = .;

  /*--------------------------------------------------------------------*/
  /* Uninitialized data segment                                         */
  /*--------------------------------------------------------------------*/

  /* Start of uninitialized data segment */
  . = .;
  _fbss = .;

  /* sbss: Uninitialized writeable small data section */
  . = .;

  /* bss: Uninitialized writeable data section */
  . = .;
  _bss_start = .;
  .bss : 
  {
    *(.bss)
    *(.bss.*)
    *(.sbss*)
    *(.gnu.linkonce.b.*)
    *(COMMON)
  }

  .sbi :
  {
    *(.sbi)
  }

  .payload :
  {
    *(.payload)
  }

  _end = .;
}
```

CPU加电后执行`0x00001000`处的首条指令，通过` auipc`跳转到`0x80000000`开始执行bbl的启动代码。可以看见bbl的入口为`reset_vector`，该符号位于`machine/mentry.S`中。Linker script中还需要注意的有`htif`、`.sbi`和`.payload`三个部分，它们分别位于`machine/mtrap.c`、`sbi_entry.S`和`bbl/payload.S`中。

### Loading Kernel

```c
void boot_loader()
{
  extern char _payload_start, _payload_end;
  load_kernel_elf(&_payload_start, &_payload_end - &_payload_start, &info);
  supervisor_vm_init();
#ifdef PK_ENABLE_LOGO
  print_logo();
#endif
  mb();
  elf_loaded = 1;
  enter_supervisor_mode((void *)info.entry, 0);
}
```

在完成编译后，我们的kernel以二进制ELF文件的形式被打包到了生成的`bbl`中，而kernel的起始和终止地址分别为`_payload_start`和`_payload_end`，BBL会读取kernel并释放到内存中，读者可以参阅`bbl/kernel_elf.c`文件以了解详细过程；之后，BBL会利用从ELF中获得的信息为kernel建立一个基本的页表，并将SBI映射到虚拟地址空间的最后一个页上；最后，`enter_supervisor_mode`函数会将控制权转交给kernel并进入S-mode。

### Supervisor Binary Interface

之前已经提到，RISC-V利用Binary Interface实现对底层环境的抽象，从而方便了各个水平的虚拟化的实现。这个想法本身是非常优秀的，可惜直到[Privileged ISA Specification v1.9.1](https://riscv.org/specifications/privileged-isa)为止，SBI的实现思路都是错误的。为了方便说明，我们先对RISC-V ISA做进一步介绍。

#### Memory Management

对于一个32位Unix-like操作系统而言，只需要用两种内存管理管理模式

* Mbare: Physical Addresses
* Sv32: Page-Based 32-bit Virtual-Memory Systems

默认情况下使用的是Mbare模式，若想启用Sv32模式，需要向`mstatus`寄存器中的VM域写入`00100`，此时若进入S-mode，系统会自动使用页式寻址。要注意的有三点

- M-mode下使用的始终是Mbare内存管理
- `mstatus`是M-mode特有的寄存器，S-mode下的`sstatus`寄存器中无VM域，若读者对此处突然提到`sstatus`感到疑惑，建议阅读[Privileged ISA Specification v1.9.1](https://riscv.org/specifications/privileged-isa) 3.1.6小节
- 页表基址对应物理页的页号存放在`spbtr`寄存器中，该寄存器为S-mode特有寄存器，M-mode和S-mode下可写可读

如果读者还记得OOP课上学过的[single responsibility principle](https://en.wikipedia.org/wiki/Single_responsibility_principle)，应该能意识到让M-mode的软件SEE决定是否启用页式寻址并让S-mode的软件OS管理页表是一件很糟糕的事情，而事实也确实是这样。

#### SBI Implementation

SBI呈现为一组函数，它的实现在`sbi_entry.S`中，OS只能获得头文件`sbi.h`和对应的函数地址`sbi.S`

```c
#ifndef _ASM_RISCV_SBI_H
#define _ASM_RISCV_SBI_H

typedef struct {
  unsigned long base;
  unsigned long size;
  unsigned long node_id;
} memory_block_info;

unsigned long sbi_query_memory(unsigned long id, memory_block_info *p);

unsigned long sbi_hart_id(void);
unsigned long sbi_num_harts(void);
unsigned long sbi_timebase(void);
void sbi_set_timer(unsigned long long stime_value);
void sbi_send_ipi(unsigned long hart_id);
unsigned long sbi_clear_ipi(void);
void sbi_shutdown(void);

void sbi_console_putchar(unsigned char ch);
int sbi_console_getchar(void);

void sbi_remote_sfence_vm(unsigned long hart_mask_ptr, unsigned long asid);
void sbi_remote_sfence_vm_range(unsigned long hart_mask_ptr, unsigned long asid, unsigned long start, unsigned long size);
void sbi_remote_fence_i(unsigned long hart_mask_ptr);

unsigned long sbi_mask_interrupt(unsigned long which);
unsigned long sbi_unmask_interrupt(unsigned long which);

#endif
```

```nasm
.globl sbi_hart_id; sbi_hart_id = -2048
.globl sbi_num_harts; sbi_num_harts = -2032
.globl sbi_query_memory; sbi_query_memory = -2016
.globl sbi_console_putchar; sbi_console_putchar = -2000
.globl sbi_console_getchar; sbi_console_getchar = -1984
.globl sbi_send_ipi; sbi_send_ipi = -1952
.globl sbi_clear_ipi; sbi_clear_ipi = -1936
.globl sbi_timebase; sbi_timebase = -1920
.globl sbi_shutdown; sbi_shutdown = -1904
.globl sbi_set_timer; sbi_set_timer = -1888
.globl sbi_mask_interrupt; sbi_mask_interrupt = -1872
.globl sbi_unmask_interrupt; sbi_unmask_interrupt = -1856
.globl sbi_remote_sfence_vm; sbi_remote_sfence_vm = -1840
.globl sbi_remote_sfence_vm_range; sbi_remote_sfence_vm_range = -1824
.globl sbi_remote_fence_i; sbi_remote_fence_i = -1808
```

上面`sbi.S`中的magic numbers就是各个函数所在的虚拟地址，为了将这些函数映射到这些位置上，BBL在加载kernel时做了一些额外的工作，之前在[Loading Kernel](#loading-kernel)部分也有提及，具体实现如下

```c
  // map SBI at top of vaddr space
  extern char _sbi_end;
  uintptr_t num_sbi_pages = ((uintptr_t)&_sbi_end - DRAM_BASE - 1) / RISCV_PGSIZE + 1;
  assert(num_sbi_pages <= (1 << RISCV_PGLEVEL_BITS));
  for (uintptr_t i = 0; i < num_sbi_pages; i++) {
    uintptr_t idx = (1 << RISCV_PGLEVEL_BITS) - num_sbi_pages + i;
    sbi_pt[idx] = pte_create((DRAM_BASE / RISCV_PGSIZE) + i, PTE_G | PTE_R | PTE_X);
  }
  pte_t* sbi_pte = middle_pt + ((num_middle_pts << RISCV_PGLEVEL_BITS)-1);
  assert(!*sbi_pte);
  *sbi_pte = ptd_create((uintptr_t)sbi_pt >> RISCV_PGSHIFT);
```

有兴趣的读者可以自行理解实现细节。

#### SBI Pitfall

> All problems in computer science can be solved by another level of indirection... Except for the problem of too many layers of indirection.
>
> — David Wheeler

虽然SBI的实现复杂得无以复加，但到目前为止似乎还没出什么逻辑上的问题，果真如此吗？让我们来看一个例子

```c
unsigned long sbi_query_memory(unsigned long id, memory_block_info *p);
```

这个SBI函数不可能被实现，因为它涉及到了传递地址的过程，而我们之前已经提到，M-mode永远工作在Mbare模式下。从kernel中传一个32位虚拟地址给SEE毫无意义，因为SEE只能看到物理地址。这样，我们发现了SBI的第一个问题

* SBI只能传值而不能传引用

第二个问题并不如第一个显然。考虑一下，既然SBI是Supervisor对SEE进行“系统”调用的过程，期间必然会发生特权级从S到M的转换，RISC-V中只有一条指令能完成这种转换——`ecall`。我们不妨来看一看`sbi_console_putchar`的实现

```nasm
# console_putchar
.align 4
li a7, MCALL_CONSOLE_PUTCHAR # MCALL_CONSOLE_PUTCHAR == 1
ecall
ret
```

所有的SBI都应该是如此实现的，但一个更合乎逻辑的Binary Interface应当是这样的——"欲使用SEE提供的console putchar功能，请将想要输出的字符放入寄存器a0，将寄存器a7置为1，并使用ecall指令"。如果上述理由不足以说服你，那么请看下面这个x86汇编程序

```nasm
section .programFlow
    global _start
    _start:
        mov edx, len
        mov ecx, msg
        mov ebx, 0x1    ;select STDOUT stream
        mov eax, 0x4    ;select SYS_WRITE call
        int 0x80        ;invoke SYS_WRITE
        mov ebx, 0x0    ;select EXIT_CODE_0
        mov eax, 0x1    ;select SYS_EXIT call
        int 0x80        ;invoke SYS_EXIT
section .programData
    msg: db "Hello World!",0xa
    len: equ $ - msg
```

我们使用了Linux操作系统提供的ABI完成了打印"Hello World!"的任务，`printf`和`putchar`等函数我们一般称之为API而非ABI。当下RISC-V中SBI的形态——一个头文件和一组函数地址——更加像是SPI而非SBI。这就是SBI存在的第二个问题

* SBI过度封装

#### SBI in BBL

```c
unsigned long sbi_query_memory(unsigned long id, memory_block_info *p);
```

前面已经说过，这个函数不可能被实现，可它确确实实在BBL中被“实现”了，读者可以参阅`machine/sbi_entry.S`和`machine/sbi_impl.c`

```nasm
# query_memory
.align 4
tail __sbi_query_memory
```

```c
uintptr_t __sbi_query_memory(uintptr_t id, memory_block_info *p)
{
  if (id == 0) {
    p->base = first_free_paddr;
    p->size = mem_size + DRAM_BASE - p->base;
    return 0;
  }

  return -1;
}
```

这个workaround似乎没有什么问题，但我们还是得仔细考量一下。`tail __sbi_query_memory`可以理解为一条jump到函数入口地址的指令，问题在于，上述代码都是在bbl中编译的，其中的地址均为物理地址，为何Supervisor能够正常调用它们呢？

原因大致有两点

* 编译器生成了[position-independent code](https://en.wikipedia.org/wiki/Position-independent_code)
* 在虚拟地址空间中，两段代码的相对位置关系和物理地址空间中的相对位置关系相同

由于上述原因，当操作系统完成对物理内存的管理后，这样的workaround也不再有效。

#### SBI in the future

SBI的众多问题有望在[Privileged ISA Specification v1.10](https://github.com/riscv/riscv-isa-manual)中得到解决，下面是我们和作者的通信

```
主　题:    
Re: I'm from Tsinghua University and have some questions about SBI in RISC-V.
发件人:    Andrew Waterman 2017-4-11 15:27:41
收件人:    张蔚
Great questions.

On Mon, Apr 10, 2017 at 8:18 PM, 张蔚 <zhangwei15@mails.tsinghua.edu.cn> wrote:
> Dear Dr. Waterman,
>
> My name is Wei Zhang and I'm an undergraduate at Tsinghua University. I'm
> working on porting our teaching operating system (ucore_os_lab) to RISC-V
> under the guidance of Prof. Chen and Prof. Xiang. And I'm confused with SBI
> in RISC-V.
>
> While investigating BBL, I realized that it's inherently difficult to pass
> reference to SBI functions since supervisor lives in virtual address space
> while SEE sees physical address space. Some SBI functions defined in
> privileged spec 1.9.1 involves passing and returning pointers, I suspect
> they can't work properly without manually doing a page walk in SEE.

Yes, this is an unfortunate complication.  We are revising the SBI for
the next version of the spec, 1.10, and have arrived at a simpler
design.  We eliminated some of the calls that pass pointers, in favor
of providing a device tree pointer upon OS boot.  It is a physical
address, but now the OS starts with address translation disabled, so
this works out fairly naturally.

The remaining calls that pass pointers (e.g. SEND_IPI) now use virtual
addresses.

>
> Another question is why SBI takes the form of a collection of virtual
> addresses. Calling a SBI function will transfer control to SEE, so there is
> supposed to be a ecall somewhere in that function. It might be more natural
> to directly tell OS-designers what they should put in each register before
> invoking ecall to get desired functionalities, so they can write a small
> library themselves to wrap things up easily. SBI entries in last page
> require extra effort for both OS-designers and SEE-writers.

Agreed.  The 1.10 design uses ECALL directly, rather than jumps to
virtual addresses.  The original approach was designed to optimize
paravirtualized guest OSes, but we decided the slight overhead in
those cases was worth the simplicity of avoiding the SBI page mapping.

>
> Could you please correct me if I have misunderstood SBI? And if above
> problems do exist, are there plans to solve them is the next privileged spec?
>
> Thank you for your help in this matter.
>
> Sincerely,
>
> Wei Zhang
>
>
>
```

### Host-Target Interface

之前介绍工具链时已经提到了Host-Target Interface (HTIF)，虽然对使用了bbl的OS开发者来说并无影响，但读者仍有必要熟悉这个重要的feature。让我们考虑一个字符是怎样被bbl输出到terminal中的。

#### Step 0: Declaring Magic Variables

首先，我们需要在源码中声明两个特殊变量`tohost`和`fromhost`，读者可以查看`machine/mtrap.c`文件

```c
volatile uint64_t tohost __attribute__((aligned(64))) __attribute__((section("htif")));
volatile uint64_t fromhost __attribute__((aligned(64))) __attribute__((section("htif")));
```

#### Step 1: Finding Magic Variables

[riscv-fesvr](https://github.com/riscv/riscv-fesvr)在加载bbl时，会在ELF文件中搜索这两个变量，并记下它们的物理地址

```cpp
std::map<std::string, uint64_t> symbols = load_elf(path.c_str(), &mem);

if (symbols.count("tohost") && symbols.count("fromhost")) {
  tohost_addr = symbols["tohost"];
  fromhost_addr = symbols["fromhost"];
} else {
  fprintf(stderr, "warning: tohost and fromhost symbols not in ELF; can't communicate with target\n");
}
```

#### Step 2: Polling

```cpp
while (!signal_exit && exitcode == 0) {
  if (auto tohost = mem.read_uint64(tohost_addr)) {
    mem.write_uint64(tohost_addr, 0);
    command_t cmd(this, tohost, fromhost_callback);
    device_list.handle_command(cmd);
  } else {
    idle();
  }

  device_list.tick();

  if (!fromhost_queue.empty() && mem.read_uint64(fromhost_addr) == 0) {
    mem.write_uint64(fromhost_addr, fromhost_queue.front());
    fromhost_queue.pop();
  }
}
```

每一个cycle，模拟器都会检测`tohost`变量的值，若不为0，说明target向host发出了某种请求，需要进一步处理。也许Wikipedia上[Polling (computer science)](https://en.wikipedia.org/wiki/Polling_(computer_science))对此过程的描述有助于理解

1. The host repeatedly reads the [busy bit](https://en.wikipedia.org/wiki/Status_register) of the controller until it becomes clear.
2. When clear, the host writes in the command [register](https://en.wikipedia.org/wiki/Hardware_register) and writes a byte into the data-out register.
3. The host sets the command-ready bit (set to 1).
4. When the controller senses command-ready bit is set, it sets busy bit.
5. The controller reads the command register and since write bit is set, it performs necessary I/O operations on the device. If the read bit is set to one instead of write bit, data from device is loaded into data-in register, which is further read by the host.
6. The controller clears the command-ready bit once everything is over, it clears error bit to show successful operation and reset busy bit (0).

#### Step 3: Writing/Reading Magic Numbers

在bbl的`machine/htif.h`头文件中，定义了一些宏来方便对`tohost`的修改和对`fromhost`的读取

```c
#if __riscv_xlen == 64
# define TOHOST_CMD(dev, cmd, payload) \
  (((uint64_t)(dev) << 56) | ((uint64_t)(cmd) << 48) | (uint64_t)(payload))
#else
# define TOHOST_CMD(dev, cmd, payload) ({ \
  if ((dev) || (cmd)) __builtin_trap(); \
  (payload); })
#endif
#define FROMHOST_DEV(fromhost_value) ((uint64_t)(fromhost_value) >> 56)
#define FROMHOST_CMD(fromhost_value) ((uint64_t)(fromhost_value) << 8 >> 56)
#define FROMHOST_DATA(fromhost_value) ((uint64_t)(fromhost_value) << 16 >> 16)
```

要注意的是，当使用32位交叉编译器时，`__riscv_xlen`的值为32，使用`TOHOST_CMD`会进入`__builtin_trap()`，根据编译器不同可能是死循环或者直接退出。`dev`、`cmd`和`payload`等参数的含义和取值，有兴趣的读者可自行研究。

### Instruction Emulation

bbl还提供了指令模拟的功能，为上层的kernel提供模拟器中未实现的指令，这也是一个值得一提的feature。让我们来考虑在S-mode下尝试读取时间时会发生什么

```c
asm volatile("rdtime a0")；
```

由于`rdtime`指令未被实现，执行这一句时会引发`Illegal instruction exception`，被bbl的trap handler捕捉

```nasm
trap_table:
  .word bad_trap
  .word bad_trap
  .word illegal_insn_trap
  .word bad_trap
  .word misaligned_load_trap
  .word bad_trap
  .word misaligned_store_trap
  .word bad_trap
  .word bad_trap
  .word mcall_trap
  .word bad_trap
  .word bad_trap
#define SOFTWARE_INTERRUPT_VECTOR 12
  .word software_interrupt
#define TIMER_INTERRUPT_VECTOR 13
  .word timer_interrupt
#define TRAP_FROM_MACHINE_MODE_VECTOR 14
  .word __trap_from_machine_mode
```

注意`trap_table`中的`illegal_insn_trap`就是`illegal instruction`的处理程序

```c
void illegal_insn_trap(uintptr_t* regs, uintptr_t mcause, uintptr_t mepc)
{
  uintptr_t mstatus;
  insn_t insn = get_insn(mepc, &mstatus);

  if (unlikely((insn & 3) != 3))
    return truly_illegal_insn(regs, mcause, mepc, mstatus, insn);

  write_csr(mepc, mepc + 4);

  extern uint32_t illegal_insn_trap_table[];
  uint32_t* pf = (void*)illegal_insn_trap_table + (insn & 0x7c);
  emulation_func f = (emulation_func)(uintptr_t)*pf;
  f(regs, mcause, mepc, mstatus, insn);
}
```

在使用`get_insn`取出“非法”指令并适当判断后，bbl会将指令交给`emulate_system_opcode`函数处理。又经过各种判断和函数调用，程序流最终到达`emulate_read_csr`函数中

```c
static inline int emulate_read_csr(int num, uintptr_t mstatus, uintptr_t* result)
{
  uintptr_t counteren =
    EXTRACT_FIELD(mstatus, MSTATUS_MPP) == PRV_U ? read_csr(mucounteren) :
                                                   read_csr(mscounteren);

  switch (num)
  {
    case CSR_TIME:
      if (!((counteren >> (CSR_TIME - CSR_CYCLE)) & 1))
        return -1;
      *result = *mtime;
      return 0;
#if __riscv_xlen == 32
    case CSR_TIMEH:
      if (!((counteren >> (CSR_TIME - CSR_CYCLE)) & 1))
        return -1;
      *result = *mtime >> 32;
      return 0;
#endif
  }
  return -1;
}
```

bbl从会从`mtime`中读取正确的时间然后返回，这里的`mtime`所指对象也是前面提到的HTIF的一部分。

从kernel层面看，执行指令后当前时间被正确放入了寄存器中，可见这类模拟对操作系统层面是完全透明的。bbl还可使用这一技巧在不支持浮点数扩展指令集的环境中模拟浮点运算。



## 附录：

### 建立 gcc-for-riscv32

#### 下载源码

```
$ sudo apt-get install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev
$ git clone https://github.com/riscv/riscv-tools.git
$ git submodule update --init --recursive
$ export RISCV=/path/to/install/riscv/toolchain
```

#### change build.comon

```
# Script to build RISC-V ISA simulator, proxy kernel, and GNU toolchain.
# Tools will be installed to $RISCV.

if [ "x$RISCV" = "x" ]
then
  echo "Please set the RISCV environment variable to your preferred install path."
  exit 1
fi

# Use gmake instead of make if it exists.
MAKE=`command -v gmake || command -v make`

PATH="$RISCV/bin:$PATH"
#GCC_VERSION=`gcc -v 2>&1 | tail -1 | awk '{print $3}'`

set -e

function build_project {
  PROJECT="$1"
  shift
  echo
  if [ -e "$PROJECT/build" ]
  then
    echo "Removing existing $PROJECT/build directory"
    rm -rf "$PROJECT/build"
  fi
  mkdir -p "$PROJECT/build"
  cd "$PROJECT/build"
  echo "Configuring project $PROJECT"
  ../configure $* > build.log
  echo "Building project $PROJECT"
  $MAKE -j8 >> build.log
  echo "Installing project $PROJECT"
  $MAKE install >> build.log
  cd - > /dev/null
}
```

#### change  build-rve32g.sh

```
#! /bin/bash
#
# Script to build RISC-V ISA simulator, proxy kernel, and GNU toolchain.
# Tools will be installed to $RISCV.

. build.common

echo "Starting RISC-V Toolchain build process"

build_project riscv-fesvr --prefix=$RISCV
# build_project riscv-isa-sim --prefix=$RISCV --with-fesvr=$RISCV --with-isa=rv32g
build_project riscv-gnu-toolchain --prefix=$RISCV --with-arch=rv32g --with-abi=ilp32d
# CC= CXX= build_project riscv-pk --prefix=$RISCV --host=riscv32-unknown-elf
echo -e "\\nRISC-V Toolchain installation completed!"

```

#### 编译安装

```
$ ./build-rv32g.sh
```

执行完毕后，会安装好gcc 7.2 for riscv32等工具。

注意：目前spike模拟器不好使，改用qemu-system-riscv32。

### 编译器参数

- `-march=ISA` selects the architecture to target. This controls which instructions and registers are available for the compiler to use.
- `-mabi=ABI` selects the ABI to target. This controls the calling convention (which arguments are passed in which registers) and the layout of data in memory.
- `-mtune=CODENAME` selects the microarchitecture to target. This informs GCC about the performance of each instruction, allowing it to perform target-specific optimizations.



#### The `-march` Argument

 RISC-V User-Level ISA v2.2 defines three base ISAs that are currently supported by the toolchain:

- RV32I: A load-store ISA with 32, 32-bit general-purpose integer registers.
- RV32E: An embedded flavor of RV32I with only 16 integer registers.
- RV64I: A 64-bit flavor of RV32I where the general-purpose integer registers are 64-bits wide.



In addition to these base ISAs, a handful of extensions have been specified. The extensions that have been specified and are supported by the toolchain are:

- M: Integer Multiplication and Division
- A: Atomic Instructions
- F: Single-Precision Floating-Point
- D: Double-Precision Floating-Point
- C: Compressed Instructions

#### 例子

test.c

```
    double dmul(double a, double b) {
      return a * b;
    }
```

will compile directly to a FP multiplication instruction when compiled with the D extension

```
    $ riscv64-unknown-elf-gcc test.c -march=rv64imafdc -mabi=lp64d -o- -S -O3
    dmul:
      fmul.d  fa0,fa0,fa1
      ret
```

but will compile to an emulation routine without the D extension

```
    $ riscv64-unknown-elf-gcc test.c -march=rv64i -mabi=lp64 -o- -S -O3
    dmul:
      add     sp,sp,-16
      sd      ra,8(sp)
      call    __muldf3
      ld      ra,8(sp)
      add     sp,sp,16
      jr      ra
```

#### The `-mabi` Argument

RISC-V defines two integer ABIs and three floating-point ABIs, which together are treated as a single ABI string. The integer ABIs follow the standard ABI naming scheme:

- `ilp32`: `int`, `long`, and pointers are all 32-bits long. `long long` is a 64-bit type, `char` is 8-bit, and `short` is 16-bit.
- `lp64`: `long` and pointers are 64-bits long, while `int` is a 32-bit type. The other types remain the same as ilp32.

while the floating-point ABIs are a RISC-V specific addition:

- ”” (the empty string): No floating-point arguments are passed in registers.
- `f`: 32-bit and smaller floating-point arguments are passed in registers. This ABI requires the F extension, as without F there are no floating-point registers.
- `d`: 64-bit and smaller floating-point arguments are passed in registers. This ABI requires the D extension.



Just like ISA strings, ABI strings are concatenated together and passed via the `-mabi` argument to GCC. In order to explain why the ISA and ABI should be treated as two separate arguments, let’s examine a handful of `-march`/`-mabi` combinations:

- `-march=rv32imafdc -mabi=ilp32d`: Hardware floating-point instructions can be generated and floating-point arguments are passed in registers. This is like the `-mfloat-abi=hard` argument to ARM’s GCC.
- `-march=rv32imac -mabi=ilp32`: No floating-point instructions can be generated and no floating-point arguments are passed in registers. This is like the `-mfloat-abi=soft` argument to ARM’s GCC.
- `-march=rv32imafdc -mabi=ilp32`: Hardware floating-point instructions can be generated, but no floating-point arguments will be passed in registers. This is like the `-mfloat-abi=softfp`argument to ARM’s GCC, and is usually used when interfacing with soft-float binaries on a hard-float system.
- `-march=rv32imac -mabi=ilp32d`: Illegal, as the ABI requires floating-point arguments are passed in registers but the ISA defines no floating-point registers to pass them in.

#### 例子

test.c

```
    double dmul(double a, double b) {
      return b * a;
    }
```

The first argument is the simplest one: if neither the ABI or ISA contains the concept of floating-point hardware then the C compiler cannot emit any floating-point-specific instructions. In this case, emulation routines are used to perform the computation and the arguments are passed in integer registers. As you can see, the double-precision arguments are passed in 32-bit integer register pairs, the order of arguments is swapped, `ra` is saved (as it’s callee saved), the emulation routine is called, the stack is unwound, and the result is returned (which is already in `a0,a1` from `__muldf3`).

```
    $ riscv64-unknown-elf-gcc test.c -march=rv32imac -mabi=ilp32 -o- -S -O3
    dmul:
      mv      a4,a2
      mv      a5,a3
      add     sp,sp,-16
      mv      a2,a0
      mv      a3,a1
      mv      a0,a4
      mv      a1,a5
      sw      ra,12(sp)
      call    __muldf3
      lw      ra,12(sp)
      add     sp,sp,16
      jr      ra
```

The second case is the exact opposite of this one: everything is supported in hardware. In this case we can emit a single `fmul.d` instruction to perform the computation, which when register allocated correctly handles reversing the input arguments and producing the return value.

```
    $ riscv64-unknown-elf-gcc test.c -march=rv32imafdc -mabi=ilp32d -o- -S -O3
    dmul:
      fmul.d  fa0,fa1,fa0
      ret
```



which produces the entire set of multilibs we support, along with their corresponding arguments:

```
riscv64-unknown-elf-gcc -march=rv32i -mabi=ilp32 => rv32i/ilp32
riscv64-unknown-elf-gcc -march=rv32ic -mabi=ilp32 => rv32i/ilp32
riscv64-unknown-elf-gcc -march=rv32iac -mabi=ilp32 => rv32iac/ilp32
riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 => rv32im/ilp32
riscv64-unknown-elf-gcc -march=rv32imc -mabi=ilp32 => rv32im/ilp32
riscv64-unknown-elf-gcc -march=rv32imac -mabi=ilp32 => rv32imac/ilp32
riscv64-unknown-elf-gcc -march=rv32imafc -mabi=ilp32f => rv32imafc/ilp32f
riscv64-unknown-elf-gcc -march=rv32imafdc -mabi=ilp32f => rv32imafc/ilp32f
riscv64-unknown-elf-gcc -march=rv64imac -mabi=lp64 => rv64imac/lp64
riscv64-unknown-elf-gcc -march=rv64imafdc -mabi=lp64d => rv64imafdc/lp64d
```

or for the Linux toolchain:

```
riscv64-unknown-linux-gnu-gcc -march=rv32ima -mabi=ilp32 => lib32/ilp32
riscv64-unknown-linux-gnu-gcc -march=rv32imac -mabi=ilp32 => lib32/ilp32
riscv64-unknown-linux-gnu-gcc -march=rv32imaf -mabi=ilp32 => lib32/ilp32
riscv64-unknown-linux-gnu-gcc -march=rv32imafc -mabi=ilp32 => lib32/ilp32
riscv64-unknown-linux-gnu-gcc -march=rv32imafd -mabi=ilp32 => lib32/ilp32
riscv64-unknown-linux-gnu-gcc -march=rv32imafdc -mabi=ilp32 => lib32/ilp32
riscv64-unknown-linux-gnu-gcc -march=rv32imafd -mabi=ilp32d => lib32/ilp32d
riscv64-unknown-linux-gnu-gcc -march=rv32imafdc -mabi=ilp32d => lib32/ilp32d
riscv64-unknown-linux-gnu-gcc -march=rv64ima -mabi=lp64 => lib64/lp64
riscv64-unknown-linux-gnu-gcc -march=rv64imac -mabi=lp64 => lib64/lp64
riscv64-unknown-linux-gnu-gcc -march=rv64imaf -mabi=lp64 => lib64/lp64
riscv64-unknown-linux-gnu-gcc -march=rv64imafc -mabi=lp64 => lib64/lp64
riscv64-unknown-linux-gnu-gcc -march=rv64imafd -mabi=lp64 => lib64/lp64
riscv64-unknown-linux-gnu-gcc -march=rv64imafdc -mabi=lp64 => lib64/lp64
riscv64-unknown-linux-gnu-gcc -march=rv64imafd -mabi=lp64d => lib64/lp64d
riscv64-unknown-linux-gnu-gcc -march=rv64imafdc -mabi=lp64d => lib64/lp64d
```



- `rv32i/ilp32`: The simplest RISC-V ISA. While we don’t expect this to see much commercial use, we expect that it’ll get a lot of educational and hobbyist use. Also, it seems a bit odd not to support the base ISA well – as otherwise what’s the point of one :).
- `rv32iac/ilp32`: Despite there being lots of tricks to produce small multipliers that are arbitrarily slow, some people seem to be allergic to hardware multiplication. This target is there to satisfy those people.
- `rv32im/ilp32`: This exists largely to support cores retrofitted from other ISAs where simple memory systems preclude the implementation of both the A and C extensions.
- `rv32imac/ilp32`: We expect this to get lots of use, it’s probably what you’d want to build if you’re building a standalone microcontroller chip.
- `rv32imafc/ilp32f`: A 32-bit, floating-point target. The other option here would have been `rv32imafdc/ilp32d`, but we chose this instead under the assumption that if you could deal with having a 64-bit FPU that you’d probably just want to build a 64-bit core.
- `rv64imac/lp64`: This will probably be the RISC-V ISA configuration that has the largest number of cores produced for the near future, as there aren’t any good options for deeply embedded cores (think power management units, IP control cores, etc) that can talk to SOCs with addresses spaces larger than 32 bits.
- `rv64imafdc/lp64d`: The “full featured” embedded core. These probably won’t be produced as embedded cores directly, but we think that people will repurpose Linux-class cores as embedded cores as Linux isn’t that expensive on RISC-V.
- ​

### 编译ELF执行程序

#### An Example of a Relocation in a C Program

 C code:

```
long global_symbol[2];
  
int main() {
  return global_symbol[0] != 0;
}
```

Even though a single GCC invocation can produce a binary for this simple case, under the covers the GCC driver script is actually running the preprocessor, then the compiler, then the assembler and finally the linker. The `--save-temps` argument to GCC allows users to see all these intermediate files, and is a useful argument for poking around inside the toolchain.

```
$ riscv64-unknown-linux-gnu-gcc relocation.c -o relocation -O3 –save-temps
```

Each step in this run of the GCC wrapper script generates a file:

- `relocation.i`: The preprocessed source, which expands any preprocessor directives (things like `#include` or `#ifdef`).
- `relocation.s`: The output of the actual compiler, which is an assembly file (a text file in the RISC-V assembly format).
- `relocation.o`: The output of the assembler, which is an un-linked object file (an ELF file, but not an executable ELF).
- `relocation`: The output of the linker, which is a linked executable (an executable ELF file).

The first step is to run the preprocessor. Since this is a simple source file with no preprocessor macros, the preprocessor run is pretty boring: all it does is emit some directives to be used if debugging information is later generated:

```
$ cat relocation.i
# 1 "relocation.c"
# 1 "built-in"
# 1 "command-line"
# 31 "command-line"
# 1 "/scratch/palmer/work/upstream/riscv-gnu-toolchain/build/install/sysroot/usr/include/stdc-predef.h" 1 3 4
# 32 "command-line" 2
# 1 "relocation.c"
long global_symbol;
  
int main() {
  return global_symbol != 0;
}
```

The preprocessed output is then fed through the compiler, which generates a assembly file. It is at this point at which we begin to see why relocations are necessary. This file is plain-text that contains RISC-V assembly code and therefore is easy to read, so let’s take a look right now:

```
$ cat relocation.s
main:
  lui   a5,%hi(global_symbol)
  ld    a0,%lo(global_symbol)(a5)
  snez  a0,a0
  ret
```

These addressing modes （`%hi(global_symbol)`and `%lo(global_symbol)(a5)`.）exist to allow the compiler to address global symbols. But the actual address of those global symbols cannot be known until link time. The next link in the toolchain is the assembler, which takes in the assembly file from above and produces an ELF object file that has not yet been linked. You can examine these object files with objdump, which I’ve done below:

```
$ riscv64-unknown-linux-gnu-objdump -d -t -r relocation.o
  
relocation.o:     file format elf64-littleriscv
  
SYMBOL TABLE:
0000000000000000 l    df *ABS*  0000000000000000 relocation.c
0000000000000000 l    d  .text  0000000000000000 .text
0000000000000000 l    d  .data  0000000000000000 .data
0000000000000000 l    d  .bss   0000000000000000 .bss
0000000000000000 l    d  .text.startup  0000000000000000 .text.startup
0000000000000000 l    d  .comment       0000000000000000 .comment
0000000000000000 g     F .text.startup  000000000000000e main
0000000000000010       O *COM*  0000000000000008 global_symbol
  
Disassembly of section .text.startup:
  
0000000000000000 main:
   0:   000007b7                lui     a5,0x0
                        0: R_RISCV_HI20 global_symbol
                        0: R_RISCV_RELAX        *ABS*
   4:   0007b503                ld      a0,0(a5) # 0 main
                        4: R_RISCV_LO12_I       global_symbol
                        4: R_RISCV_RELAX        *ABS*
   8:   00a03533                snez    a0,a0
   c:   8082                    ret
```

Now is the first point at which you get to explicitly see a relocation (which are only shown when the `-r`argument is passed to objdump). Here we can see four RISC-V-specific relocations in two pairs: a`R_RISCV_HI20`+`R_RISCV_RELAX` pair for the `lui` and a `R-RISCV_LO12_I`+`R_RISCV_RELAX` pair for the `ld`. The `R_RISCV_RELAX` relocations exist solely to signify that it is legal to perform linker relaxation on the previous relocation. Since we’re not talking about linker relaxation in this blog entry, we can just ignore those entries for now.

The other two relocations pair explicitly with an addressing mode present in the RISC-V ISA: `R_RISCV_HI20` pairs with a U-format immediate while `R_RISCV_LO12_I` pairs with an I-format immediate. In general, you’ll find that every addressing mode with an immediate will have at least one relocation that fills out that immediate – sometimes there’ll be a handful more if that instruction format is used to link against more complicated forms of symbols as well (for example, PIC or TLS relocations).

Before we get too deep into relocations, let’s quickly examine how the toolchain works when it’s possible to fill out a relocation correctly. The next link in the toolchain is the linker, which consumes the relocations generated by the assembler to fill our the relevant bits in the output ELF executable. The program now has all the glibc startup code so it’s become quite large. Thus, I’m only posting the relevant snippets below:

```
$ riscv64-unknown-linux-gnu-objdump -d -t -r relocation
relocation:     file format elf64-littleriscv
  
SYMBOL TABLE:
0000000000012038 g     O .bss 0000000000000010              global_symbol
...
  
Disassembly of section .text:
  
0000000000010330 main:
 10330:       67c9                    lui     a5,0x12
 10332:       0387b503                ld      a0,56(a5) # 12038 global_symbol   56=0x38
 10336:       00a03533                snez    a0,a0
 1033a:       8082                    ret
```

#### The `relocation truncated to fit` Error Message

Now that you know a bit about what relocations are we can discuss most people’s only exposure to relocations: the `relocation truncated to fit` error message that appears when linking. It’s hard to explain this message to people who don’t understand relocations, but if you understand what a relocation is then it’s not actually that tricky of an error message.

In order to explain the error message, we’ll start with an extremely simple program. In this case we don’t want anything from the C library to show up in our error message so we’re defining `_start` instead of `main` and then avoiding any standard library objects by passing `-nostdlib -nostartfiles` to GCC – this program won’t actually work, but it’ll serve to explain what’s going on. Moving the text section with `-Wl,-Ttext-segment,0x80000000` will actually trigger the bug, you’ll see why below:

```
$ cat reloc_fail.c
long global_symbol;
int _start() {
  return global_symbol;
}
$ riscv64-unknown-linux-gnu-gcc reloc_fail.c -o reloc_fail -O3 -nostartfiles -nostdlib --save-temps  -Wl,-Ttext-segment,0x80000000
reloc_fail.o: In function `_start':
reloc_fail.c:(.text+0x0): relocation truncated to fit: R_RISCV_HI20 against symbol `global_symbol' defined in COMMON section in reloc_fail.o
/scratch/palmer/work/20170725-binutils-2.29/install/bin/../lib/gcc/riscv64-unknown-linux-gnu/7.1.1/../../../../riscv64-unknown-linux-gnu/bin/ld: final link failed: Symbol needs debug section which does not exist
collect2: error: ld returned 1 exit status
```

First, let’s focus on only the important part of the error message and ignore all the cruft that’s not actually relevant. The actual error you want to look at here is:

```
reloc_fail.c:(.text+0x0): relocation truncated to fit: R_RISCV_HI20 against symbol `global_symbol'
```

which simply states that the compiler generated a `R_RISCV_HI20` relocation against the address `global_symbol`, but that the linker was unable fit the symbol’s full address into the bits specified by that relocation. The phrase “truncated to fit” is a bit odd: what the linker is actually saying is that the address in the relocation must be truncated to fit into the bits allocated by the relocation if it was to fit, but since this is an error the linker isn’t really truncating anything.

In order to start really delving into the “why” of the error message, we need to first look at the input to the linker, which in this case is the object file generated by the assembler. Like the above example, we need the relocation because the compiler needs to reference a global symbol that it can’t know the address for.

```
$ riscv64-unknown-linux-gnu-objdump -d -r reloc_fail.o
reloc_fail.o:     file format elf64-littleriscv

Disassembly of section .text:

0000000000000000 <_start>:
   0:   000007b7                lui     a5,0x0
                        0: R_RISCV_HI20 global_symbol
                        0: R_RISCV_RELAX        *ABS*
   4:   0007a503                lw      a0,0(a5) # 0 <_start>
                        4: R_RISCV_LO12_I       global_symbol
                        4: R_RISCV_RELAX        *ABS*
   8:   8082                    ret
```

We modified the linker to omit the range check when performing relocations with the patch shown below:

```
$ git diff
diff --git a/bfd/elfnn-riscv.c b/bfd/elfnn-riscv.c
index 3c04507623c3..f8a97411de35 100644
--- a/bfd/elfnn-riscv.c
+++ b/bfd/elfnn-riscv.c
@@ -1492,8 +1492,6 @@ perform_relocation (const reloc_howto_type *howto,
     case R_RISCV_GOT_HI20:
     case R_RISCV_TLS_GOT_HI20:
     case R_RISCV_TLS_GD_HI20:
-      if (ARCH_SIZE > 32 && !VALID_UTYPE_IMM (RISCV_CONST_HIGH_PART (value)))
-       return bfd_reloc_overflow;
       value = ENCODE_UTYPE_IMM (RISCV_CONST_HIGH_PART (value));
       break;
```

With the above patch, the linker can generate an incorrect object file that we can inspect, which I’ve shown below:

```
$ riscv64-unknown-linux-gnu-objdump -d -t reloc_fail
reloc_fail:     file format elf64-littleriscv

SYMBOL TABLE:
00000000800000b0 l    d  .text  0000000000000000 .text
00000000800010c0 l    d  .bss   0000000000000000 .bss
0000000000000000 l    d  .comment       0000000000000000 .comment
0000000000000000 l    df *ABS*  0000000000000000 reloc_fail.c
00000000800018ba g       .text  0000000000000000 __global_pointer$
00000000800010c0 g     O .bss   0000000000000008 global_symbol
00000000800000b0 g     F .text  000000000000000a _start
00000000800010ba g       .bss   0000000000000000 __bss_start
00000000800010ba g       .bss   0000000000000000 _edata
00000000800010c8 g       .bss   0000000000000000 _end

Disassembly of section .text:

00000000800000b0 <_start>:
    800000b0:   800017b7                lui     a5,0x80001
    800000b4:   0c07a503                lw      a0,192(a5) # ffffffff800010c0 <__global_pointer$+0xfffffffefffff806>
    800000b8:   8082                    ret
```

As we can clearly see, the instructions that load the value of `global_symbol` do not actually match the address of `global_symbol` as listed by the symbol table, which is exactly what the `relocation truncated to fit` error message is trying to say. In the particular case of the`R_RISCV_HI20`+`R_RISCV_LO12_I` relocation pair the largest absolute address that can be generated is `0x7FFFFFFF` – remember U-type immediates are signed on RISC-V, so any larger absolute address overflows on RV64.

### Link Relaxation

#### concept of Link relaxation

[[https://en.wikipedia.org/wiki/Linker_(computing)#Relaxation]]

As the compiler has no information on the layout of objects in the final output, it cannot take advantage of shorter or more efficient instructions that place a requirement on the address of another object. For example, a jump instruction can reference an absolute address or an offset from the current location, and the offset could be expressed with different lengths depending on the distance to the target. By generating the most conservative instruction (usually the largest relative or absolute variant, depending on platform) and adding *relaxation hints*, it is possible to substitute shorter or more efficient instructions during the final link. This step can be performed only after all input objects have been read and assigned temporary addresses; the **linker relaxation** pass subsequently reassigns addresses, which may in turn allow more relaxations to occur. In general, the substituted sequences are shorter, which allows this process to always converge on the best solution given a fixed order of objects; if this is not the case, relaxations can conflict, and the linker needs to weigh the advantages of either option.

While instruction relaxation typically occurs at [link-time](https://en.wikipedia.org/wiki/Link-time), inner-module relaxation can already take place as part of the optimising process at [compile-time](https://en.wikipedia.org/wiki/Compile-time). In some cases, relaxation can also occur at [load-time](https://en.wikipedia.org/wiki/Load-time) as part of the relocation process or combined with [dynamic dead-code elimination](https://en.wikipedia.org/wiki/Dynamic_dead-code_elimination) techniques.

#### example

Linker relaxation is a mechanism for optimizing programs at link-time, as opposed to traditional program optimization which happens at compile-time. Linker relaxation is a concept so important it has greatly shaped the design of the RISC-V ISA.  Below is a example:

```
$ cat test.c
int func(int a) __attribute__((noinline));
int func(int a) {
  return a + 1;
}

int _start(int a) {
  return func(a);
}
$ riscv64-unknown-linux-gnu-gcc test.c  -o test -O3 -nostartfiles -nostdlib --save-temps  -Wl,-Ttext-segment,0x8000000
$ riscv64-unknown-linux-gnu-objdump -d -r test.o
test.o:     file format elf64-littleriscv
Disassembly of section .text:

0000000000000000 <func>:
   0:   2505                    addiw   a0,a0,1
   2:   8082                    ret

0000000000000004 <_start>:
   4:   00000317                auipc   ra,0x0
                        4: R_RISCV_CALL func
                        4: R_RISCV_RELAX        *ABS*
   8:   00030067                jr      ra
```

You can now see a new RISC-V relocation: `R_RISCV_CALL`. This relocation sits between an `auipc` and a `jalr` instruction (here disassembled as the `jr` shorthand as this is a tail call) and points to the symbol that should be the target of the jump, in this case the `func` symbol. The `R_RISCV_CALL` relocation is paired with a `R_RISCV_RELAX` relocation, which allows the linker to relax this relocation pair

In order to understand relaxation, we first must examine the RISC-V ISA a bit. In the RISC-V ISA there are two unconditional control transfer instructions: `jalr`, which jumps to an absolute address as specified by an immediate offset from a register; and `jal`, which jumps to a pc-relative offset as specified by an immediate. The only differences between the `auipc`+`jalr` pair in this object file and a single `jal` are that the pair can address a 32-bit signed offset from the current PC while the `jal` can only address a 21-bit signed offset from the current PC, and that the `jal` instruction is half the size (which is a good proxy for twice the speed).

As the compiler cannot know if the offset between `_start` and `func` will fit within a 21-bit offset, it is forced to generate the longer call. We don’t want to impose this cost in cases where it’s not necessary, so we instead optimize this case in the linker. Let’s look at the executable to see the result of linker relaxation:

```
$ riscv64-unknown-linux-gnu-objdump -d -r test
test:     file format elf64-littleriscv

Disassembly of section .text:

0000000000010078 <func>:
   10078:       2505                    addiw   a0,a0,1
   1007a:       8082                    ret

000000000001007c <_start>:
   1007c:       ffdff06f                j       10078 <func>
```

As you can see, the linker knows that the call from `_start` to `func` fits within the 21-bit offset of the `jal` instruction and converts it to a single instruction.

#### The RISC-V Implementation of Linker Relaxation

While the concept of linker relaxation is fairly straight-forward, there are a lot of tricky details that need to be done correctly in order to ensure the linker produces the correct symbol addresses everywhere. To the best of my knowledge, the RISC-V BFD port make the most aggressive use of linker relaxations: essentially no `.text` section symbol addresses are known until link time. 

The actual implementation of linker relaxation is, as you’d expect, fairly esoteric. The code lives in `_bfd_riscv_relax_section` inside `binutils-gdb/bfd/elfnn-riscv.c`, which looks roughly like the following:

```
_bfd_riscv_relax_section:
  if section shouldn't be relaxed:
    return DONE
  for each relocation:
    if relocation is relaxable:
      store per-relocation function pointer
    read the symbol table
    obtain the symbol's address
    call the per-relocation function
```

Essentially, all it’s doing is some shared bookkeeping code and then calling a relocation-specific function to actually relax the relocation. The relax functions all look somewhat similar, so I’ll show an example of the function that relaxes `R_RISCV_CALL` relocation that was discussed above

```
_bfd_riscv_relax_call:
  compute a pessimistic address range
  if relocation doesn't fit into a UJ-type immediate:
    return DONE
  compute offsets for various short jumps
  if RVC is enabled and the relocation fits in a C.JAL:
    convert the jump to c.jal
  if relocation fits in an JAL:
    convert the jump to a jal
  if call target is near absolute address 0:
    convert the jump to a x0-offset JALR
  delete the JALR, as it's not necessary any more
```



### The RISC-V Code Models

The RISC-V ISA was designed to be both simple and modular. In order to achieve these design goals, RISC-V minimizes one of the largest costs in implementing complex ISAs: addressing modes. Addressing modes are expensive both in small designs (due to decode cost) and large designs (due to implicit dependencies). RISC-V only has three addressing modes:

- PC-relative, via the `auipc`, `jal` and `br*` instructions.
- Register-offset, via the `jalr`, `addi` and all memory instructions.
- Absolute, via the `lui` instruction (though arguably this is just `x0`-offset).

#### concept of code model

Most programs do not fill the entire address space available to them with symbols (most don’t fill it at all, but those that do tend to fill their address space with heap). ISAs tend to take advantage of this locality by implementing shorter addressing modes in hardware and relying on software to provide larger address modes. The code model determines which software addressing mode is used, and, therefore, what constraints are enforced on the linked program. Software addressing modes determine how the programmer sees addresses, as opposed to hardware addressing modes which determine how address bits in instructions are handled.

Code models are necessary due to the split between the compiler and the linker: when generating an unlinked object, the complier doesn’t know the absolute address of any symbol but it still must know what addressing mode to use as some addressing modes may require scratch registers to operate. As the compiler cannot generate actual addressing code, it generates addressing templates (known as[relocations](https://www.sifive.com/blog/2017/08/21/all-aboard-part-2-relocations)) that the linker can then fix up once it knows the actual addresses of each symbol. The code model determines what these addressing templates look like, and thus which relocations are emitted.

#### example

code:

```
long global_symbol[2];

int main() {
  return global_symbol[0] != 0;
}
```

compile:

```
$ riscv64-unknown-linux-gnu-gcc cmodel.c -o cmodel -O3 --save-temps
```

Each step in this run of the GCC wrapper script generates a file:

- `cmodel.i`: The preprocessed source, which expands any preprocessor directives (things like `#include` or `#ifdef`).
- `cmodel.s`: The output of the actual compiler, which is an assembly file (a text file in the RISC-V assembly format).
- `cmodel.o`: The output of the assembler, which is an unlinked object file (an ELF file, but not an executable ELF).
- `cmodel`: The output of the linker, which is a linked executable (an executable ELF file).

cmodel.i

```
# 1 "cmodel.c"
# 1 "built-in"
# 1 "command-line"
# 31 "command-line"
# 1 "/scratch/palmer/work/upstream/riscv-gnu-toolchain/build/install/sysroot/usr/include/stdc-predef.h" 1 3 4
# 32 "command-line" 2
# 1 "cmodel.c"
long global_symbol;

int main() {
  return global_symbol != 0;
}
```

cmodel.s

```
main:
  lui   a5,%hi(global_symbol)
  ld    a0,%lo(global_symbol)(a5)
  snez  a0,a0
  ret
```

The generated assembly contains a pair of instructions to address `global_symbol`: `lui` and then `ld`. This imposes a constraint on the address that `global_symbol` can take on: it must be addressable by a 32-bit signed absolute constant (not 32-bit offset from some register or the PC, but actually a 32-bit address). Note that the restriction on symbol addresses is not related to the size of a pointer on this architecture: specifically pointers may still be 64 bits here, but all global symbols must be addressable by a 32-bit absolute address.

After the compiler generates assembly, the GCC wrapper script calls the assembler to generate an object file. This file is an ELF binary, which can be read with a variety of tools provided by Binutils. In case we’ll use `objdump` to show the symbol table, disassemble the text section and show the relocations generated by the assembler:

```
$ riscv64-unknown-linux-gnu-objdump -d -t -r cmodel.o

cmodel.o:     file format elf64-littleriscv

SYMBOL TABLE:
0000000000000000 l    df *ABS*  0000000000000000 cmodel.c
0000000000000000 l    d  .text  0000000000000000 .text
0000000000000000 l    d  .data  0000000000000000 .data
0000000000000000 l    d  .bss   0000000000000000 .bss
0000000000000000 l    d  .text.startup  0000000000000000 .text.startup
0000000000000000 l    d  .comment       0000000000000000 .comment
0000000000000000 g     F .text.startup  000000000000000e main
0000000000000010       O *COM*  0000000000000008 global_symbol

Disassembly of section .text.startup:

0000000000000000 main:
   0:   000007b7                lui     a5,0x0
                        0: R_RISCV_HI20 global_symbol
                        0: R_RISCV_RELAX        *ABS*
   4:   0007b503                ld      a0,0(a5) # 0 main
                        4: R_RISCV_LO12_I       global_symbol
                        4: R_RISCV_RELAX        *ABS*
   8:   00a03533                snez    a0,a0
   c:   8082                    ret
```

At this point we have an object file, but we still don’t know the actual addresses of any global symbols. This is where there’s a bit of overlap in the roles of each component of the toolchain: it’s the assembler’s job to convert textual instructions into bits, but in the cases where those bits depend on the address of a global symbol (like the `lui` in the code above, for example) the assembler can’t know what those bits should actually be. In order to allow the linker to fill out these bits in the final executable object file, the assembler generates entries in a relocation table for every bit range the linker is expected to fill out. Relocations define a bit range that the linker is meant to fill out when linking the code together. The specific definition of any relocation type present in the text section is ISA-specific, the RISC-V definitions can be found in our [ELF psABI document](https://github.com/riscv/riscv-elf-psabi-doc/blob/master/riscv-elf.md).

After assembling the program, the GCC wrapper script runs the linker to generate an executable. This is another ELF file, but this time it’s a full executable. Since this contains lots of C library code, I’m going to show only the relevant fragments of it here:

```
$ riscv64-unknown-linux-gnu-objdump -d -t -r cmodel
cmodel:     file format elf64-littleriscv

SYMBOL TABLE:
0000000000012038 g     O .bss    0000000000000010              global_symbol
...

Disassembly of section .text:

0000000000010330 main:
 10330:       67c9                    lui     a5,0x12
 10332:       0387b503                ld      a0,56(a5) # 12038 global_symbol
 10336:       00a03533                snez    a0,a0
 1033a:       8082                    ret
```

Until now, this example has been using RISC-V’s default code model [medlow](https://www.sifive.com/blog/2017/09/11/all-aboard-part-4-risc-v-code-models/?__hstc=753710.e46c7b81c636c9b6fa4ecb288ea3aebf.1517276509822.1517276509822.1517276509822.1&__hssc=753710.1.1517276509822&__hsfp=708807989#what-does--mcmodelmedlow-mean). In order to demonstrate a bit more specifically what a code model is it’s probably best to contrast this with our other code model, [medany](https://www.sifive.com/blog/2017/09/11/all-aboard-part-4-risc-v-code-models/?__hstc=753710.e46c7b81c636c9b6fa4ecb288ea3aebf.1517276509822.1517276509822.1517276509822.1&__hssc=753710.1.1517276509822&__hsfp=708807989#what-does--mcmodelmedany-mean). The difference can be summed up with a single example output:

```
0000000000000000 main:
   0:   00000797                auipc   a5,0x0
                        0: R_RISCV_PCREL_HI20   global_symbol
                        0: R_RISCV_RELAX        *ABS*
   4:   0007b503                ld      a0,0(a5) # 0 main
                        4: R_RISCV_PCREL_LO12_I .LA0
                        4: R_RISCV_RELAX        *ABS*
   8:   00a03533                snez    a0,a0
   c:   8082                    ret
```

Specifically, the [medany](https://www.sifive.com/blog/2017/09/11/all-aboard-part-4-risc-v-code-models/?__hstc=753710.e46c7b81c636c9b6fa4ecb288ea3aebf.1517276509822.1517276509822.1517276509822.1&__hssc=753710.1.1517276509822&__hsfp=708807989#what-does--mcmodelmedany-mean) code model generates `auipc`/`ld` pairs to refer to global symbols, which allows the code to be linked at any address; while [medlow](https://www.sifive.com/blog/2017/09/11/all-aboard-part-4-risc-v-code-models/?__hstc=753710.e46c7b81c636c9b6fa4ecb288ea3aebf.1517276509822.1517276509822.1517276509822.1&__hssc=753710.1.1517276509822&__hsfp=708807989#what-does--mcmodelmedlow-mean) generates `lui`/`ld` pairs to refer to global symbols, which restricts the code to be linked around address zero. They both generate 32-bit signed offsets for referring to symbols, so they both restrict the generated code to being linked within a 2GiB window.

#### What does -mcmodel=medlow mean?

This selects the medium-low [code model](https://www.sifive.com/blog/2017/09/11/all-aboard-part-4-risc-v-code-models/?__hstc=753710.e46c7b81c636c9b6fa4ecb288ea3aebf.1517276509822.1517276509822.1517276509822.1&__hssc=753710.1.1517276509822&__hsfp=708807989#what-is-a-code-model), which means program and its statically defined symbols must lie within a single 2 GiB address range and must lie between absolute addresses -2 GiB and +2 GiB. Addressing for global symbols uses `lui`/`addi` instruction pairs, which emit the `R_RISCV_HI20`/`R_RISCV_LO12_I` sequences. Here’s an example of some generated code using the medlow code model:

```
$ cat cmodel.c
long global_symbol[2];

int main() {
  return global_symbol[0] != 0;
}

$ riscv64-unknown-linux-gnu-gcc cmodel.c -o cmodel -O3 --save-temps -mcmodel=medlow

$ cat cmodel.s
main:
        lui     a5,%hi(global_symbol)
        ld      a0,%lo(global_symbol)(a5)
        snez    a0,a0
        ret

$ riscv64-unknown-linux-gnu-objdump -d -r cmodel.o
cmodel.o:     file format elf64-littleriscv

Disassembly of section .text.startup:

0000000000000000 main:
   0:   000007b7                lui     a5,0x0
                        0: R_RISCV_HI20 global_symbol
                        0: R_RISCV_RELAX        *ABS*
   4:   0007b503                ld      a0,0(a5) # 0 main
                        4: R_RISCV_LO12_I       global_symbol
                        4: R_RISCV_RELAX        *ABS*
   8:   00a03533                snez    a0,a0
   c:   8082                    ret

$ riscv64-unknown-linux-gnu-objdump -d -r cmodel
Disassembly of section .text:

0000000000010330 main:
   10330:       67c9                    lui     a5,0x12
   10332:       0387b503                ld      a0,56(a5) # 12038 global_symbol
   10336:       00a03533                snez    a0,a0
   1033a:       8082                    ret
```

#### What does -mcmodel=medany mean?

This selects the medium-any [code model](https://www.sifive.com/blog/2017/09/11/all-aboard-part-4-risc-v-code-models/?__hstc=753710.e46c7b81c636c9b6fa4ecb288ea3aebf.1517276509822.1517276509822.1517276509822.1&__hssc=753710.1.1517276509822&__hsfp=708807989#what-is-a-code-model), which means the program and its statically defined symbols must lie within any single 2 GiB address range. Addressing for global symbols uses `lui`/`addi`instruction pairs, which emit the `R_RISCV_PCREL_HI20`/`R_RISCV_PCREL_LO12_I` sequences. Here’s an example of some generated code using the medany code model (with `-mexplicit-relocs`, in order to make this match the [-mcmodel=medlow](https://www.sifive.com/blog/2017/09/11/all-aboard-part-4-risc-v-code-models/?__hstc=753710.e46c7b81c636c9b6fa4ecb288ea3aebf.1517276509822.1517276509822.1517276509822.1&__hssc=753710.1.1517276509822&__hsfp=708807989#what-does--mcmodelmedlow-mean) example a bit more cleanly):

```
$ cat cmodel.c
long global_symbol[2];

int main() {
  return global_symbol[0] != 0;
}

$ riscv64-unknown-linux-gnu-gcc cmodel.c -o cmodel -O3 --save-temps -mcmodel=medany -mexplicit-relocs

$ cat cmodel.s
main:
        .LA0: auipc     a5,%pcrel_hi(global_symbol)
        ld      a0,%pcrel_lo(.LA0)(a5)
        snez    a0,a0
        ret

$ riscv64-unknown-linux-gnu-objdump -d -r cmodel.o
cmodel.o:     file format elf64-littleriscv

SYMBOL TABLE:
0000000000000000 l    df *ABS*  0000000000000000 cmodel.c
0000000000000000 l    d  .text  0000000000000000 .text
0000000000000000 l    d  .data  0000000000000000 .data
0000000000000000 l    d  .bss   0000000000000000 .bss
0000000000000000 l    d  .text.startup  0000000000000000 .text.startup
0000000000000000 l       .text.startup  0000000000000000 .LA0
0000000000000000 l    d  .comment       0000000000000000 .comment
0000000000000000 g     F .text.startup  000000000000000e main
0000000000000010       O *COM*  0000000000000008 global_symbol

Disassembly of section .text.startup:

0000000000000000 main:
   0:   00000797                auipc   a5,0x0
                        0: R_RISCV_PCREL_HI20   global_symbol
                        0: R_RISCV_RELAX        *ABS*
   4:   0007b503                ld      a0,0(a5) # 0 main
                        4: R_RISCV_PCREL_LO12_I .LA0
                        4: R_RISCV_RELAX        *ABS*
   8:   00a03533                snez    a0,a0
   c:   8082                    ret

$ riscv64-unknown-linux-gnu-objdump -d -r cmodel.o
Disassembly of section .text:

0000000000010330 main:
   10330:       00002797                auipc   a5,0x2
   10334:       d087b503                ld      a0,-760(a5) # 12038 global_symbol
   10338:       00a03533                snez    a0,a0
   1033c:       8082                    ret
        ...
```

Note that that `-mcmodel=medany` currently defaults to `-mno-explicit-relocs`, which can have an appreciable performance effect. There’s a bit of nuance in that performance effect, so we’ll discuss it in a later blog.